%Seaghan Sefton
%Research Language Paper
%Work in Progress


%Preamble%
    \documentclass[12pt, letterpaper]{article}
    \usepackage{pdfpages} %for including PDFs. see Graphicx for more info
    \usepackage{amsmath} %for \mvert and other relation symbol
    \usepackage{amssymb} %for semantic delta=
    \usepackage{amsthm} 
    \usepackage{stmaryrd} %for semantics [[ and ]]
    \usepackage{dsfont} %for fancy set letters
    \usepackage{fancyhdr} %fancy headers
    %\usepackage{array} %Include if {tabular}{>{$}c<{$}} type arrays are required
    \let\emptyset\varnothing
    \pagestyle{fancy}
    \lhead{Seaghan Sefton}
    \rhead{Page \thepage}

\title{Research Language}
\author{Seaghan Sefton}
%the above title and author are unecessary

\newcommand\interp[1]{\llbracket #1 \rrbracket}

\begin{document}

\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 1 %%%
%%% SYNTAX          %%%
%%%%%%%%%%%%%%%%%%%%%%%

    %Definitions table
    \begin{tabular}{l r c l}
        Instruction Fields   & $f_{i}$   & $::=$     & $f_{i_{1}} \mid \dots \mid f_{i_{k}}$\\
        Result Fields   & $f_{r}$   & $::=$     & $f_{r_{1}} \mid \dots \mid f_{r_{k}}$\\
        Fields          & $f$       & $::=$     & $f_i \mid f_r$ \\
        Instructions         & $i$       & $::=$     & $\{f_{i_{1}} = v_{i_{1}} ,\ \dots\ ,\ f_{i_{k}} = v_{i_{k}}\}$\\
        Results         & $r$       & $::=$     & $\{f_{r_{1}} = v_{r_{1}} ,\ \dots\ ,\ f_{r_{k}} = v_{r_{k}}\}$\\
    \end{tabular}\\

    %Predicates table
    \begin{tabular}{l c r l l}
        Predicates  & $a,b$     & $::=$  & $0$          & \textit{Identity} \\
                    &           & $\mid$ & $1$          & \textit{False}    \\
                    &           & $\mid$ & $f=n$        & \textit{Test} \\  
                    &           & $\mid$ & $a + b$      & \textit{Sum}      \\
                    &           & $\mid$ & $a \cdot b$  & \textit{Product}  \\
                    &           & $\mid$ & $\neg \ a$   & \textit{Negation}
    \end{tabular}\\

    %Policies table
    \begin{tabular}{l c r l l}
        Policies    & $p,q$ & $::=$  & $a$              & \textit{Test}     \\
                    &       & $\mid$ & $act(p)$         & \textit{Slice Actions}    \\
                    &       & $\mid$ & $res(p)$         & \textit{Slice Results}    \\
                    &       & $\mid$ & $inj_{i}$        & \textit{Injection Action} \\
                    &       & $\mid$ & $inj_{r}$        & \textit{Injection Result} \\
                    &       & $\mid$ & $f \leftarrow n$ & \textit{Update}   \\
                    &       & $\mid$ & $p + q$          & \textit{Choice}   \\
                    &       & $\mid$ & $p \cdot q$      & \textit{Sequential Concatenation} \\
                    &       & $\mid$ & $p ^{*}$         & \textit{Kleene Star}
    \end{tabular}\\
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 1 %%%
%%% SYNTAX           %%%
%%%%%%%%%%%%%%%%%%%%%%%%


%Semantics Definitions
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 2 %%%
%%% SEMANTICS       %%%
%%%%%%%%%%%%%%%%%%%%%%%
 %{\fontsize{12pt}{14pt}\selectfont
    %Semantics align
    \begin{align*}
        %
        \interp{ \cdot }\ 
            :\ \ &
            P(A)\times P(R) \rightarrow P(A)\times P(R) 
            \\
        %Falsity
        \interp{ 0 }(-, -)
            \triangleq\ &
            (\emptyset , \emptyset)
            \\ %or should I use {}?
        %Identity
        \interp{ 1 }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \mathit{rs})
            \\
        %Test
        \interp{ f=n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{filter}\ (f=n)\ \mathit{is},
             \mathsf{filter}\ (f=n)\ \mathit{rs}) 
            \\
        %Sum
        \interp{ a + b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp{ a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp{ b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cup \mathit{is}_b,\mathit{rs}_a \cup \mathit{rs}_b) 
            \\
        %Product
        \interp { a \cdot b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp { b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cap \mathit{is}_b,\mathit{rs}_a \cap \mathit{rs}_b) 
            \\
        %Negation
        \interp { \neg a }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is} - \mathit{is}',\mathit{rs} - \mathit{rs}') 
            \\
        %Action-only Slice
        \interp { act(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is}',\mathit{rs}) 
            \\
        %Result-only Slice
        \interp { res(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is},\mathit{rs}')
            \\
        %Injection Action
        \interp { inj_{i}(i) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\{i\} \cup \mathit{is}, \mathit{rs})
            \\
        %Injection Result
        \interp { inj_{r}(r) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \{r\} \cup \mathit{rs})
            \\
        %Modification
        \interp { f \leftarrow n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{map}\ (f\leftarrow n)\ \mathit{is},
             \mathsf{map}\ (f\leftarrow n)\ \mathit{rs})
            \\
        %Policy Union
         \interp { p + q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_p,\mathit{rs}_p) =
            \interp { p }(\mathit{is}, \mathit{rs}) 
            \\
            &\mathsf{let}\ (\mathit{is}_q,\mathit{rs}_q) =
            \interp { q }(\mathit{is}, \mathit{rs}) 
            \\
            &(\mathit{is}_p \cup \mathit{is}_q,\mathit{rs}_p \cup \mathit{rs}_b) 
            \\
        %Policy Concatnation
        \interp { p \cdot q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') =
            \interp { p }(\mathit{is}, \mathit{rs})
            \\
            &\interp { q }(\mathit{is}', \mathit{rs}')
            \\
        %Policy Kleene Star
        \interp { p ^{*} } (\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ p^{n} = p_{1} \cdot p_{2} \cdot \ldots \cdot p_{n}
            \\
            &\mathsf{let}\ (\mathit{is_{p_{n}}}, \mathit{rs_{p_{n}}}) = \interp { p^{n} } (is, rs)
            \\
            &(\bigcup^{\infty}_{n=0} \mathit{is_{p_{n}}}, \bigcup^{\infty}_{n=0} \mathit{rs_{p_{n}}})
            \\  
        %Below may need work
        \dots & \dots \dots \\
    \end{align*}
    %This is required because it will overflow the page otherwise.
    \begin{align*}
        \mathsf{let}\ ls \in\ & is\cup rs\\
        %Defn. of Filter
        \interp{\mathsf{filter}(f=n)}(ls)
            \triangleq\ &
            \mathsf{let}\ \mathit{ls[f_j]} = \mathit{v_j}\\
            &ls' \in \{ls\ |\ ls[f_j] == n\}\\
            %Or this: ls[f_j] == n\\ ?
            %Or this: ls' \in \{ls\ \mathsf{if}\ ls[f_j] == n\}\\
             % meaning "if ls[f_j] == n" instead of "where"
          %A filter that takes a set of instructions and results returns the set of only instructions and results that satisfy some condition f=n the filter is given
          % '|' is used to mean "where"
          % e.g. ls' \in \{ls\ |\ ls[f_j] == n\} means "All ls' in the set of ls where the field f_j value v_j of ls is equal to n"
        %Defn. of Map
        \interp{\mathsf{map}}
            \triangleq\ &
            \mathsf{let}\ \mathit{ls[f_j]} = \mathit{v_j}\\
            &ls'\ |\ ls[f_j] = n
          %A map that takes a set of instruction and results returns a new set of instructions and results where the field(s) f are updated to some value n given as f \leftarrow n
          % ls{f_j} = n is used to mean "assign n to f_j".
          % should it be specified that n is only assigned to relevant fields? Probably.
    \end{align*}
 %}
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 2 %%%
%%% SEMANTICS        %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Applications}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 3 %%%
%%% APPLICATIONS    %%%
%%%%%%%%%%%%%%%%%%%%%%%

\subsection{No Writes To $\mathsf{R}_0$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{R}_{\mathsf{dest}} \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{(*empty*)}\\
   \mathsf{WritesToZero} &\triangleq& \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \\
   \mathsf{NoWritesToZero} &\triangleq& \mathit{act}(\neg\mathsf{WritesToZero})
 \end{array}
 \]
 
 Prove that
 \begin{itemize}
 \item  if
   $\interp{ \mathsf{NoWritesZero} } (\mathit{is}, \mathit{rs}) =
   (\mathit{is}', \mathit{rs}')$
 \item then
   \begin{enumerate}
   \item $\mathit{rs} = \mathit{rs'}$ and
   \item for all $i \in \mathit{is}'$, $i.\mathsf{R}_{\mathsf{dest}} \neq \mathsf{R}_0$.
   \end{enumerate}
 \end{itemize}
 \begin{proof}
 %    \hfill  \\
 %  \begin{tabular}{rl}
 %    %\label{step1}
 %    $\interp{\mathsf{NoWritesToZero}}
 %    = \interp{\mathit{act}(\neg \mathsf{WritesToZero})}$
 %    & Defn.\\
 %    %\label{step2}
 %    $\interp{\mathit{act}(\neg \mathsf{WritesToZero})}
 %    = \interp{act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}$
 %    & Defn.\\
 %    %\label{step3}
 %    $\interp{act(\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0))}(\mathit{is},\mathit{rs})
 %    = ((\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
 %    & Defn. $\interp{\cdot}$\\    
 %    %\label{step4}
 %    $\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})
 %    = (\mathit{is},\mathit{rs}) - \interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})$
 %    & Defn. $\interp{\cdot}$\\    
 %    %\label{step5}
 %    $\interp{\mathsf{NoWritesToZero}}(\mathit{is},\mathit{rs})
 %    = (\mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
 %    & \ref{step1,step2,step3,step4}\\
 %    %\label{step6}
 %    $is' = \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1$ & \ref{step5} \\
 %    %\label{step7}
 %    $rs' = rs$ & \ref{step5}
 %  \end{tabular}
 
 %Reference https://tex.stackexchange.com/questions/33585/change-font-size-of-an-align-environment
 %Allows the proof to be smaller without changing the entire paper font size.  Paper can be reduced in size in the future but the proofs can remain smaller for width reasons.
 Thm 3.1.1:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
   \begin{alignat}{2}
     \setcounter{equation}{0}
     %\text{Statements} &&\quad \text{Reasons}\\
     \label{3.1.1:step1}
     \interp{\mathsf{NoWritesToZero}}
     &= \interp{\mathit{act}(\neg \mathsf{WritesToZero})}
     &&\quad \text{Defn.}\\
     \label{3.1.1:step2}
     \interp{\mathit{act}(\neg \mathsf{WritesToZero})}
     &= \interp{act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}
     &&\quad \text{Defn.}\\
     \label{3.1.1:step3}
     \interp{act(\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0))}(\mathit{is},\mathit{rs})
     &= ((\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})).1, \mathit{rs})
     &&\quad \text{Defn.}\ \interp{\cdot}\\    
     \label{3.1.1:step4}
     \interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})
     &= (\mathit{is},\mathit{rs}) - \interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})
     &&\quad \text{Defn.}\ \interp{\cdot}\\    
     \label{3.1.1:step5}
     \interp{\mathsf{NoWritesToZero}}(\mathit{is},\mathit{rs})
     &= (\mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1, \mathit{rs})
     &&\quad \ref{3.1.1:step1},\ref{3.1.1:step2},\ref{3.1.1:step3},\ref{3.1.1:step4}\\
     \label{3.1.1:step6}
     is' &= \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1
     &&\quad \ref{3.1.1:step5} \\
     %Add, by deconstruction of (is,rs) pair?
     \label{3.1.1:step7}
     rs' &= rs 
     &&\quad \ref{3.1.1:step5} \\
     %Add, by deconstruction of (is,rs) pair?
     \label{3.1.1:step8}
     %& \mathsf{Q.E.D.}
     &\qedhere
    &&\quad \ref{3.1.1:step7}
   \end{alignat}
 }%
 \end{proof}
 
 \begin{proof}
 %be careful when using \ref between a \setcounter{equation}{0} because it will NOT change the ref (as far as my testing has proven)
 Thm 3.1.2:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
   \begin{alignat}{2}
     \label{3.1.2:step1}
     is' &= \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1
     &&\quad \ref{3.1.1:step5} \\
     \label{3.1.2:step2}
     &\qedhere
     &&\quad \ref{3.1.2:step1} %\\
     %\label{3.1.2:step3}
   \end{alignat}
 }%
     
 \end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Secure Memory Access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{PC} \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{ADDR} \\
   \mathsf{SecureAddr} &\triangleq& \mathsf{ADDR} = 0 + \mathsf{ADDR} = 1 + \ldots + \mathsf{ADDR} = 100 \\
   \mathsf{SecureInstr} &\triangleq& \mathsf{PC} = 0 + \mathsf{PC} = 1 + \ldots + \mathsf{PC} = 100 \\
 %  \mathsf{MemInstr} &\triangleq& \mathsf{OPCODE} = \mathsf{read} + \mathsf{OPCODE} = \mathsf{write} \\
   \mathsf{SecureMemoryAccess} &\triangleq&
     \mathit{act}(\mathsf{SecureInstr}) +
     (\mathit{act}(\neg\mathsf{SecureInstr}) \cdot
      \mathit{res}(\neg\mathsf{SecureAddr}))
      
 \end{array}
 \]

 Prove
 \begin{itemize}
     \item the results of secure instructions are unchanged, and
     \item the results of insecure instructions accessing insecure areas are unchanged.
 \end{itemize}

 \paragraph{Lemma \#1}
     A filter sliced to actions over a set where the actions satisfy the filter, returns itself.
 \[
     \interp{ act(f=\mathsf{A}) } (\mathit{is}_{[\mathsf{A}]}, \mathit{rs}) = (\mathit{is_{[\mathsf{A}]}}, \mathit{rs})
 \]
     Let (1) define $(\mathit{is}', \mathit{rs}')$, and simplify.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \setcounter{equation}{0}
     \interp{ act(f=\mathsf{A}) } (\mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ (f=\mathsf{A}) } (\mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     The definition of action slice is used to transform (1) into (2).  (2) to (3) is true because a filter over a set that satisfies the filter is the set itself.\\
 \paragraph{Lemma \#2}
     It follows that the converse would result in no $\mathit{is}$ in the evaluated set:
 \[
     \interp{ act(\neg f=\mathsf{A}) } (\mathit{is}_{[\mathsf{A}]}, \mathit{rs}) = (\emptyset, \mathit{rs})
 \]

 \paragraph{Proof 3.2.1}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over some $(\mathit{is},\mathit{rs})$ can be unraveled into a syntactically correct equation given the above definitions.  $\mathsf{SI}$ is short for $\mathsf{SecureInstr}$, $\mathsf{SA}$ is short for $\mathsf{SecureAddr}$, and $\mathsf{SMA}$ is short for $\mathsf{SecureMemoryAccess}$:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \setcounter{equation}{0}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA})) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     Beginning with the left side of the union unraveled further, and evaluated over $(\mathit{is}_{[\mathsf{SI}]},\mathit{rs})$, the simplification using Lemma \#1 results in (6):
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \interp{ \mathit{act} (\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ \mathit{act} (PC=0\ldots 100) } (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup \ldots %should probably use element of insead of = for is_{PC}
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup \ldots 
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     The right side can be evaluated similarly.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \ldots \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\ %
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     (\mathit{is_{\mathsf{SI}}}, \interp{ (\neg\mathsf{SA}) } \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs} - \interp{ (\mathsf{SA}) } \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}') %
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs} - \interp{ (\mathsf{SA}) } \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     The left side of the intersection can be evaluated to $(\emptyset, \mathit{rs})$ Lemma \#2 from (8) to (9). The right side of the intersection can be evaluated by the definition of negation and result slicing, (9) to (11).  The intersection is then evaluated over both to give (12).  The union can be evaluated as:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup 
     (\emptyset, \mathit{rs} - \interp{ (\mathsf{SA}) } \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }% 
     (13) simplifies to (14) because the union of a set and the empty set is the first set, and the expression $\mathit{rs} - \interp{ (\mathsf{SA}) } \mathit{rs}$ is by definition a subset of $\mathit{rs}$.  This leaves $\mathit{rs} = \mathit{rs}'$, proving part 1. 

 \paragraph{Proof 3.2.2}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over insecure actions and results is to be proven to not change the results.  This idea can be written to equal some $(\mathit{is}', \mathit{rs}')$, and then simplified in the same way as the beginning of Proof 3.2.1
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \setcounter{equation}{0}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}))  } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     Following the same format, the expression to the left of the union is evaluated first.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     Lemma \#2 in the previous proof simplifies this easily.\\
     The expression to the right of the union is now evaluated.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     \ldots \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     Lemma \#1 is used to simplfy the left side of the intersection, and a result-version of Lemma \#1 is used to simplify the right side of the intersection. (10) contains the evaluated intersection.\\
     The left and right sides of the union can be rejoined and evaluated to determine the exact equivalence of $(\mathit{is}', \mathit{rs}')$:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{align}
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}}) \cup
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
 }%
     In (12), it is shown that the evaluated results are unchanged, and it can additionally be said that none of the instructions have been changed from the initial input as well.  This proves part 2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lock Bits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each instruction is associated with a lock bit.
Only the monitor can update lock bits.
Certain operations like writing to a particular part of the address space
require that the lock bit be set. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{rcl}
  \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{Lock_{Instr}}, \mathsf{IC}\\
  \mathsf{IC} &::=& \mathsf{MEM_{READ}}\ |\ \mathsf{MEM_{WRITE}}\ |\ \cdots \\
  \mathit{Result\ Fields}\ f_r &::=& \mathsf{Lock_{MemAddr}}\\
  \mathsf{LockedInstr} &\triangleq& \mathsf{Lock_{Instr}} = \mathsf{TRUE} \\
  \mathsf{LockedMem} &\triangleq& \mathsf{Lock_{MemAddr}} = \mathsf{TRUE} \\
  \mathsf{Read} &\triangleq& \mathsf{IC} = \mathsf{MEM_{READ}}\\
  \mathsf{Write} &\triangleq& \mathsf{IC} = \mathsf{MEM_{WRITE}}\\
  %Rule
  \mathsf{LockSecure} &\triangleq& 
    act(\mathsf{LockedInstr})\cdot res(\mathsf{LockedMem})\\
    &&+
    act(\mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem}) \cdot \mathsf{inj_{MEM-LOCK}} \\
  \mathsf{LockInsecure} &\triangleq&
    act(\neg \mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem})\\
  \mathsf{Locked} &\triangleq& \mathsf{LockSecure} + \mathsf{LockInsecure}
\end{array}
\]\\
$\mathsf{Locked}$ is defined in english as "Any locked instruction can access anything, but it must lock it if it's not locked.  Any unlocked instruction can only access unlocked memory."\\
It would be interesting to prove if this is equal to the locked instruction accessing ANYTHING, and then ALWAYS setting it to locked.

%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 3 %%%
%%% APPLICATIONS    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
