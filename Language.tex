%Seaghan Sefton
%Research Language Paper
%Semantics Due September 28 2017

%Preamble%
    \documentclass[12pt, letterpaper]{article}
    \usepackage{pdfpages} %for including PDFs. see Graphicx for more info
    \usepackage{amsmath} %for \mvert and other relation symbol
    \usepackage{amssymb} %for semantic delta=
    \usepackage{stmaryrd} %for semantics [[ and ]]
    \usepackage{dsfont} %for fancy set letters
    \usepackage{fancyhdr} %fancy headers
    %\usepackage{array} %Include if {tabular}{>{$}c<{$}} type arrays are required
    \let\emptyset\varnothing
    \pagestyle{fancy}
    \lhead{Seaghan Sefton}
    \rhead{Page \thepage}

\title{Research Language}
\author{Seaghan Sefton}
%the above title and author are unecessary

\begin{document}

\section{Syntax}
    %\paragraph{Predicates}

    %TO DO%
    %Define a_{s} and r_{s}

    %Definitions table
    \begin{tabular}{l r c l}
        Instruction Fields   & $f_{i}$   & $::=$     & $f_{i_{1}} \mid \dots \mid f_{i_{k}}$\\
        Result Fields   & $f_{r}$   & $::=$     & $f_{r_{1}} \mid \dots \mid f_{r_{k}}$\\
        Fields          & $f$       & $::=$     & $f_i \mid f_r$ \\
        Instructions         & $i$       & $::=$     & $\{f_{i_{1}} = v_{i_{1}} ,\ \dots\ ,\ f_{a_{k}} = v_{i_{k}}\}$\\
        Results         & $r$       & $::=$     & $\{f_{r_{1}} = v_{r_{1}} ,\ \dots\ ,\ f_{r_{k}} = v_{r_{k}}\}$\\
    \end{tabular}\\
    %Predicates table
    \begin{tabular}{l c r l l}
        Predicates  & $a,b$     & $::=$  & $0$          & \textit{Identity} \\
                    &           & $\mid$ & $1$          & \textit{False}    \\
                    &           & $\mid$ & $f=n$        & \textit{Test} \\  
                    &           & $\mid$ & $a + b$      & \textit{Sum}      \\
                    &           & $\mid$ & $a \cdot b$  & \textit{Product}  \\
                    &           & $\mid$ & $\neg \ a$   & \textit{Negation}
    \end{tabular}\\
    %Policies table
    \begin{tabular}{l c r l l}
        Policies    & $p,q$ & $::=$  & $a$              & \textit{Test}     \\
                    &       & $\mid$ & $act(p)$         & \textit{Slice Actions}    \\
                    &       & $\mid$ & $res(p)$         & \textit{Slice Results}    \\
                    &       & $\mid$ & $inj_{i}$        & \textit{Injection Action} \\
                    &       & $\mid$ & $inj_{r}$        & \textit{Injection Result} \\
                    &       & $\mid$ & $f \leftarrow n$ & \textit{Update}   \\
                    &       & $\mid$ & $p + q$          & \textit{Choice}   \\
                    &       & $\mid$ & $p \cdot q$      & \textit{Sequential Concatenation} \\
                    &       & $\mid$ & $p ^{*}$         & \textit{Kleene Star}
    \end{tabular}\\
    %Semantics Definitions
    %$Test \triangleq Other$
\section{Semantics}

    %\begin{tabular}{>{\small}c}
    %   test q test
    %\end{tabular}
    \begin{align*}
        \llbracket \cdot \rrbracket\ 
            :\ \ &
            P(A)\times P(R) \rightarrow P(A)\times P(R) 
            \\
        %Falsity
        \llbracket 0 \rrbracket(-, -)
            \triangleq\ &
            (\emptyset , \emptyset)
            \\ %or should I use {}?
        %Identity
        \llbracket 1 \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \mathit{rs})
            \\
        %Test
        \llbracket f=n \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{filter}\ (f=n)\ \mathit{is},
             \mathsf{filter}\ (f=n)\ \mathit{rs}) 
            \\
        %Sum
        \llbracket a + b \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \llbracket b \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cup \mathit{is}_b,\mathit{rs}_a \cup \mathit{rs}_b) 
            \\
        %Product
        \llbracket a \cdot b \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \llbracket b \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cap \mathit{is}_b,\mathit{rs}_a \cap \mathit{rs}_b) 
            \\
        %Negation
        \llbracket \neg a \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is} - \mathit{is}',\mathit{rs} - \mathit{rs}') 
            \\
        %Action-only Slice
        \llbracket act(p) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \llbracket p\rrbracket(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is}',\mathit{rs}) 
            \\
        %Result-only Slice
        \llbracket res(p) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \llbracket p\rrbracket(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is},\mathit{rs}')
            \\
        %Injection Action
        \llbracket inj_{i}(i) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\{i\} \cup \mathit{is}, \mathit{rs})
            \\
        %Injection Result
        \llbracket inj_{r}(r) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \{r\} \cup \mathit{rs})
            \\
        %Modification
        \llbracket f \leftarrow n \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{map}\ (f\leftarrow n)\ \mathit{is},
             \mathsf{map}\ (f\leftarrow n)\ \mathit{rs})
            \\
        %Policy Union
         \llbracket p + q \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_p,\mathit{rs}_p) =
            \llbracket p \rrbracket(\mathit{is}, \mathit{rs}) 
            \\
            &\mathsf{let}\ (\mathit{is}_q,\mathit{rs}_q) =
            \llbracket q \rrbracket(\mathit{is}, \mathit{rs}) 
            \\
            &(\mathit{is}_p \cup \mathit{is}_q,\mathit{rs}_p \cup \mathit{rs}_b) 
            \\
        %Policy Concatnation
        \llbracket p \cdot q \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') =
            \llbracket p \rrbracket(\mathit{is}, \mathit{rs})
            \\
            &\llbracket q \rrbracket(\mathit{is}', \mathit{rs}')
            \\
        %Below need work
        \dots & \dots \dots \\
        %Policy Kleene Star
        \llbracket p ^{*} \rrbracket (\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ p^{n} = p_{1} \cdot p_{2} \cdot \ldots \cdot p_{n}
            \\
            &\mathsf{let}\ (\mathit{is_{p_{n}}}, \mathit{rs_{p_{n}}}) = \llbracket p^{n} \rrbracket (is, rs)
            \\
            &(\bigcup^{\infty}_{n=0} \mathit{is_{p_{n}}}, \bigcup^{\infty}_{n=0} \mathit{rs_{p_{n}}})
            \\
    \end{align*}

\section{Applications}

\subsection{No Writes To $\mathsf{R}_0$}

\[
\begin{array}{rcl}
  \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{R}_{\mathsf{dest}} \\
  \mathit{Result\ Fields}\ f_r &::=& \mathsf{(*empty*)}\\
  \mathsf{WritesToZero} &\triangleq& \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \\
  \mathsf{NoWritesToZero} &\triangleq& \mathit{act}(\neg\mathsf{WritesToZero})
\end{array}
\]

Prove that
\begin{itemize}
\item  if
  $\llbracket \mathsf{NoWritesZero} \rrbracket (\mathit{is}, \mathit{rs}) =
  (\mathit{is}', \mathit{rs}')$
\item then
  \begin{enumerate}
  \item $\mathit{rs} = \mathit{rs'}$ and
  \item for all $i \in \mathit{is}'$, $i.\mathsf{R}_{\mathsf{dest}} \neq \mathsf{R}_0$.
  \end{enumerate}
\end{itemize}
\paragraph{Proof}
    Given the above definitions, the following can be unraveled into a syntactically-correct equation.:
\begin{align}
    \llbracket \mathsf{NoWritesZero} \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
    \\
    \llbracket act(\neg \mathsf{WritesToZero}) \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
    \\
    \llbracket act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0) \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
\end{align}
    Action can then be unraveled semantically using the definition of action slice:
                %Do I need to define something?
\begin{align}
    \llbracket act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0) \rrbracket (\mathit{is}, \mathit{rs}) 
    =
    (\mathit{is}', \mathit{rs})
\end{align}
    And so by substitution:
\begin{align}
    (\mathit{is}', \mathit{rs}')
    &=
    (\mathit{is}', \mathit{rs})
\end{align}
    And it has been proven that $\mathit{rs} = \mathit{rs'}$.\\
    Substituting (4) and (5) into (3) gives (6), which can be substituted with (7), the definition of negation, to get (8). 
\begin{align}
    \llbracket \neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs})\\
    \llbracket \neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}, \mathit{rs}) - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs})\\ %this is a rule using the definition of negation for the next equation.
    (\mathit{is}, \mathit{rs}) - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs})
\end{align}
    (8) can be simplified using algebra.
\begin{align}    
    - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}) - (\mathit{is}, \mathit{rs})
    \\
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}, \mathit{rs}) - (\mathit{is}', \mathit{rs})
\end{align}
    The definition of a test can be unraveled into a filter result, and $\mathit{rs}$ can be canceled out of (10) for simplicity as rs has no field $\mathsf{R_{dest}}$.  Substitution of (12), the definition of a test and filter, into (11) will give (13).
\begin{align}
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is})
    &=
    (\mathit{is}) - (\mathit{is}')
    \\
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is})
    &=
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
    \\
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
    &=
    (\mathit{is}) - (\mathit{is}')
    \\
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}}) - (\mathit{is}) 
    &=
    \\
    - (\mathit{is}')
    &=
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}}) - (\mathit{is})
    \\
    (\mathit{is}')
    &=
    (\mathit{is}) - (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
\end{align}
    The final simplification (16) means that $\mathit{is}'$ is equal to all $\mathit(is)$ \textit{without} all $\mathit(is)$ where $\mathsf{R_{dest}} = \mathsf{R_{0}}$.
    This in equation form is $\mathit{is}' = \mathit{is_{[\mathsf{R_{dest} \neq \mathsf{R_{0}}}]}}$, or all result instructions do not write to $\mathsf{R_{0}}$.  The second theorem has been proven.


\subsection{Secure Memory Access}

\[
\begin{array}{rcl}
  \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{PC} \\
  \mathit{Result\ Fields}\ f_r &::=& \mathsf{ADDR} \\
  \mathsf{SecureAddr} &\triangleq& \mathsf{ADDR} = 0 + \mathsf{ADDR} = 1 + \ldots + \mathsf{ADDR} = 100 \\
  \mathsf{SecureInstr} &\triangleq& \mathsf{PC} = 0 + \mathsf{PC} = 1 + \ldots + \mathsf{PC} = 100 \\
%  \mathsf{MemInstr} &\triangleq& \mathsf{OPCODE} = \mathsf{read} + \mathsf{OPCODE} = \mathsf{write} \\
  \mathsf{SecureMemoryAccess} &\triangleq&
    \mathit{act}(\mathsf{SecureInstr}) +
    (\mathit{act}(\neg\mathsf{SecureInstr}) \cdot
     \mathit{res}(\neg\mathsf{SecureAddr}))
     
\end{array}
\]

Prove
\begin{itemize}
\item the results of secure instructions are unchanged, and
\item the results of insecure instructions accessing insecure areas are unchanged.
  \end{itemize}

\subsection{Lock Bits}

Each instruction is associated with a lock bit.
Only the monitor can update lock bits.
Certain operations like writing to a particular part of the address space
require that the lock bit be set. 

\end{document}
