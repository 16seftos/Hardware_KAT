%Seaghan Sefton
%Research Language Paper
%Work in Progress


%Preamble%
    \documentclass[12pt, letterpaper]{article}
    \usepackage{pdfpages} %for including PDFs. see Graphicx for more info
    \usepackage{amsmath} %for \mvert and other relation symbol
    \usepackage{amssymb} %for semantic delta=
    \usepackage{amsthm} 
    \usepackage{stmaryrd} %for semantics [[ and ]]
    \usepackage{dsfont} %for fancy set letters
    \usepackage{fancyhdr} %fancy headers
    %\usepackage{array} %Include if {tabular}{>{$}c<{$}} type arrays are required
    \let\emptyset\varnothing
    \pagestyle{fancy}
    \lhead{Seaghan Sefton}
    \rhead{Page \thepage}

\title{Research Language}
\author{Seaghan Sefton}
%the above title and author are unecessary

\newcommand\interp[1]{\llbracket #1 \rrbracket}

\begin{document}

\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 1 %%%
%%% SYNTAX          %%%
%%%%%%%%%%%%%%%%%%%%%%%

    %Definitions table
    \begin{tabular}{l r c l}
        Instruction Fields   & $f_{i}$   & $::=$     & $f_{i_{1}} \mid \dots \mid f_{i_{k}}$\\
        Result Fields   & $f_{r}$   & $::=$     & $f_{r_{1}} \mid \dots \mid f_{r_{k}}$\\
        Fields          & $f$       & $::=$     & $f_i \mid f_r$ \\
        Instructions         & $i$       & $::=$     & $\{f_{i_{1}} = v_{i_{1}} ,\ \dots\ ,\ f_{i_{k}} = v_{i_{k}}\}$\\
        Results         & $r$       & $::=$     & $\{f_{r_{1}} = v_{r_{1}} ,\ \dots\ ,\ f_{r_{k}} = v_{r_{k}}\}$\\
    \end{tabular}\\

    %Predicates table
    \begin{tabular}{l c r l l}
        Predicates  & $a,b$     & $::=$  & $0$          & \textit{Identity} \\
                    &           & $\mid$ & $1$          & \textit{False}    \\
                    &           & $\mid$ & $f=n$        & \textit{Test} \\  
                    &           & $\mid$ & $a + b$      & \textit{Sum}      \\
                    &           & $\mid$ & $a \cdot b$  & \textit{Product}  \\
                    &           & $\mid$ & $\neg \ a$   & \textit{Negation}
    \end{tabular}\\

    %Policies table
    \begin{tabular}{l c r l l}
        Policies    & $p,q$ & $::=$  & $a$              & \textit{Test}     \\
                    &       & $\mid$ & $act(p)$         & \textit{Slice Actions}    \\
                    &       & $\mid$ & $res(p)$         & \textit{Slice Results}    \\
                    &       & $\mid$ & $inj_{i}$        & \textit{Injection Action} \\
                    &       & $\mid$ & $inj_{r}$        & \textit{Injection Result} \\
                    &       & $\mid$ & $f \leftarrow n$ & \textit{Update}   \\
                    &       & $\mid$ & $p + q$          & \textit{Choice}   \\
                    &       & $\mid$ & $p \cdot q$      & \textit{Sequential Concatenation} \\
                    &       & $\mid$ & $p ^{*}$         & \textit{Kleene Star}
    \end{tabular}\\
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 1 %%%
%%% SYNTAX           %%%
%%%%%%%%%%%%%%%%%%%%%%%%


%Semantics Definitions
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 2 %%%
%%% SEMANTICS       %%%
%%%%%%%%%%%%%%%%%%%%%%%
    %Semantics align
    \begin{align*}
        %
        \llbracket \cdot \rrbracket\ 
            :\ \ &
            P(A)\times P(R) \rightarrow P(A)\times P(R) 
            \\
        %Falsity
        \llbracket 0 \rrbracket(-, -)
            \triangleq\ &
            (\emptyset , \emptyset)
            \\ %or should I use {}?
        %Identity
        \llbracket 1 \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \mathit{rs})
            \\
        %Test
        \llbracket f=n \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{filter}\ (f=n)\ \mathit{is},
             \mathsf{filter}\ (f=n)\ \mathit{rs}) 
            \\
        %Sum
        \llbracket a + b \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \llbracket b \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cup \mathit{is}_b,\mathit{rs}_a \cup \mathit{rs}_b) 
            \\
        %Product
        \llbracket a \cdot b \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \llbracket b \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cap \mathit{is}_b,\mathit{rs}_a \cap \mathit{rs}_b) 
            \\
        %Negation
        \llbracket \neg a \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') = \llbracket a \rrbracket(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is} - \mathit{is}',\mathit{rs} - \mathit{rs}') 
            \\
        %Action-only Slice
        \llbracket act(p) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \llbracket p\rrbracket(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is}',\mathit{rs}) 
            \\
        %Result-only Slice
        \llbracket res(p) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \llbracket p\rrbracket(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is},\mathit{rs}')
            \\
        %Injection Action
        \llbracket inj_{i}(i) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\{i\} \cup \mathit{is}, \mathit{rs})
            \\
        %Injection Result
        \llbracket inj_{r}(r) \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \{r\} \cup \mathit{rs})
            \\
        %Modification
        \llbracket f \leftarrow n \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{map}\ (f\leftarrow n)\ \mathit{is},
             \mathsf{map}\ (f\leftarrow n)\ \mathit{rs})
            \\
        %Policy Union
         \llbracket p + q \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_p,\mathit{rs}_p) =
            \llbracket p \rrbracket(\mathit{is}, \mathit{rs}) 
            \\
            &\mathsf{let}\ (\mathit{is}_q,\mathit{rs}_q) =
            \llbracket q \rrbracket(\mathit{is}, \mathit{rs}) 
            \\
            &(\mathit{is}_p \cup \mathit{is}_q,\mathit{rs}_p \cup \mathit{rs}_b) 
            \\
        %Policy Concatnation
        \llbracket p \cdot q \rrbracket(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') =
            \llbracket p \rrbracket(\mathit{is}, \mathit{rs})
            \\
            &\llbracket q \rrbracket(\mathit{is}', \mathit{rs}')
            \\
        %Below need work
        \dots & \dots \dots \\
        %Policy Kleene Star
        \llbracket p ^{*} \rrbracket (\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ p^{n} = p_{1} \cdot p_{2} \cdot \ldots \cdot p_{n}
            \\
            &\mathsf{let}\ (\mathit{is_{p_{n}}}, \mathit{rs_{p_{n}}}) = \llbracket p^{n} \rrbracket (is, rs)
            \\
            &(\bigcup^{\infty}_{n=0} \mathit{is_{p_{n}}}, \bigcup^{\infty}_{n=0} \mathit{rs_{p_{n}}})
            \\
    \end{align*}
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 2 %%%
%%% SEMANTICS        %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Applications}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 3 %%%
%%% APPLICATIONS    %%%
%%%%%%%%%%%%%%%%%%%%%%%

\subsection{No Writes To $\mathsf{R}_0$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\[
\begin{array}{rcl}
  \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{R}_{\mathsf{dest}} \\
  \mathit{Result\ Fields}\ f_r &::=& \mathsf{(*empty*)}\\
  \mathsf{WritesToZero} &\triangleq& \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \\
  \mathsf{NoWritesToZero} &\triangleq& \mathit{act}(\neg\mathsf{WritesToZero})
\end{array}
\]

Prove that
\begin{itemize}
\item  if
  $\llbracket \mathsf{NoWritesZero} \rrbracket (\mathit{is}, \mathit{rs}) =
  (\mathit{is}', \mathit{rs}')$
\item then
  \begin{enumerate}
  \item $\mathit{rs} = \mathit{rs'}$ and
  \item for all $i \in \mathit{is}'$, $i.\mathsf{R}_{\mathsf{dest}} \neq \mathsf{R}_0$.
  \end{enumerate}
\end{itemize}
\begin{proof}
    \hfill  \\
  \begin{tabular}{rl}
    \label{step1}$\interp{\mathsf{NoWritesToZero}}
    = \interp{\mathit{act}(\neg \mathsf{WritesToZero})}$
    & Defn.\\
    \label{step2}$\interp{\mathit{act}(\neg \mathsf{WritesToZero})}
    = \interp{act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}$
    & Defn.\\
    \label{step3}$\interp{act(\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0))}(\mathit{is},\mathit{rs})
    = ((\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
    & Defn. $\interp{\cdot}$\\    
    \label{step4}
    $\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})
    = (\mathit{is},\mathit{rs}) - \interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})$
    & Defn. $\interp{\cdot}$\\    
    \label{step5}
    $\interp{\mathsf{NoWritesToZero}}(\mathit{is},\mathit{rs})
    = (\mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
    & \ref{step1,step2,step3,step4}\\
    \label{step6}
    $is' = \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1$ & \ref{step5} \\
    \label{step7}
    $rs' = rs$ & \ref{step5}    
  \end{tabular}
  \hfill \\
\end{proof}

    Given the above definitions, the following can be unraveled into a syntactically-correct equation:
\begin{align}
    \setcounter{equation}{0}
    \llbracket \mathsf{NoWritesZero} \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
    \\
    \llbracket act(\neg \mathsf{WritesToZero}) \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
    \\
    \llbracket act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0) \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}')
\end{align}
    Action can then be unraveled semantically using the definition of action slice:
    %Do I need to define something or do it as I did below?
\begin{align}
    \llbracket act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0) \rrbracket (\mathit{is}, \mathit{rs}) 
    =
    (\mathit{is}', \mathit{rs})
\end{align}
    And so by substitution:
\begin{align}
    (\mathit{is}', \mathit{rs}')
    &=
    (\mathit{is}', \mathit{rs})
\end{align}
    And it has been proven that $\mathit{rs} = \mathit{rs'}$.\\
    Substituting (4) and (5) into (3) gives (6), which can be substituted with (7), the definition of negation, to get (8). 
\begin{align}
    \llbracket \neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs})\\
    \llbracket \neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}, \mathit{rs}) - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs})\\ %this is a rule using the definition of negation for the next equation.
    (\mathit{is}, \mathit{rs}) - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs})
\end{align}
    (8) can be simplified using algebra.
\begin{align}    
    - \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}', \mathit{rs}) - (\mathit{is}, \mathit{rs})
    \\
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is}, \mathit{rs}) 
    &=
    (\mathit{is}, \mathit{rs}) - (\mathit{is}', \mathit{rs})
\end{align}
    The definition of a test can be unraveled into a filter result, and $\mathit{rs}$ can be canceled out of (10) for simplicity as rs has no field $\mathsf{R_{dest}}$.  Substitution of (12), the definition of a test and filter, into (11) will give (13).
\begin{align}
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is})
    &=
    (\mathit{is}) - (\mathit{is}')
    \\
    \llbracket \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \rrbracket (\mathit{is})
    &=
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
    \\
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
    &=
    (\mathit{is}) - (\mathit{is}')
    \\
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}}) - (\mathit{is}) 
    &=
    \\
    - (\mathit{is}')
    &=
    (\mathit{is_{[\mathsf{R_{dest}=R0}]}}) - (\mathit{is})
    \\
    (\mathit{is}')
    &=
    (\mathit{is}) - (\mathit{is_{[\mathsf{R_{dest}=R0}]}})
\end{align}
    The final simplification (16) means that $\mathit{is}'$ is equal to all $\mathit(is)$ \textit{without} all $\mathit(is)$ where $\mathsf{R_{dest}} = \mathsf{R_{0}}$.
    This in equation form is $\mathit{is}' = \mathit{is_{[\mathsf{R_{dest} \neq \mathsf{R_{0}}}]}}$, or all result instructions do not write to $\mathsf{R_{0}}$.  The second theorem has been proven.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Secure Memory Access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{PC} \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{ADDR} \\
   \mathsf{SecureAddr} &\triangleq& \mathsf{ADDR} = 0 + \mathsf{ADDR} = 1 + \ldots + \mathsf{ADDR} = 100 \\
   \mathsf{SecureInstr} &\triangleq& \mathsf{PC} = 0 + \mathsf{PC} = 1 + \ldots + \mathsf{PC} = 100 \\
 %  \mathsf{MemInstr} &\triangleq& \mathsf{OPCODE} = \mathsf{read} + \mathsf{OPCODE} = \mathsf{write} \\
   \mathsf{SecureMemoryAccess} &\triangleq&
     \mathit{act}(\mathsf{SecureInstr}) +
     (\mathit{act}(\neg\mathsf{SecureInstr}) \cdot
      \mathit{res}(\neg\mathsf{SecureAddr}))
      
 \end{array}
 \]

 Prove
 \begin{itemize}
     \item the results of secure instructions are unchanged, and
     \item the results of insecure instructions accessing insecure areas are unchanged.
 \end{itemize}

 \paragraph{Lemma \#1}
     A filter sliced to actions over a set where the actions satisfy the filter, returns itself.
 \[
     \llbracket act(f=\mathsf{A}) \rrbracket (\mathit{is}_{[\mathsf{A}]}, \mathit{rs}) = (\mathit{is_{[\mathsf{A}]}}, \mathit{rs})
 \]
     Let (1) define $(\mathit{is}', \mathit{rs}')$, and simplify.
 \begin{align}
     \setcounter{equation}{0}
     \llbracket act(f=\mathsf{A}) \rrbracket (\mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
     \\
     (\llbracket (f=\mathsf{A}) \rrbracket \mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is}_{[\mathsf{A}]}, \mathit{rs})
     &= 
     (\mathit{is}', \mathit{rs}')
 \end{align}
     The definition of action slice is used to transform (1) into (2).  (2) to (3) is true because a filter over a set that satisfies the filter is the set itself.\\
 \paragraph{Lemma \#2}
     It follows that the converse would result in no $\mathit{is}$ in the evaluated set:
 \[
     \llbracket act(\neg f=\mathsf{A}) \rrbracket (\mathit{is}_{[\mathsf{A}]}, \mathit{rs}) = (\emptyset, \mathit{rs})
 \]

 \paragraph{Proof 3.2.1}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over some $(\mathit{is},\mathit{rs})$ can be unraveled into a syntactically correct equation given the above definitions.  $\mathsf{SI}$ is short for $\mathsf{SecureInstr}$, $\mathsf{SA}$ is short for $\mathsf{SecureAddr}$, and $\mathsf{SMA}$ is short for $\mathsf{SecureMemoryAccess}$:
 \begin{align}
     \setcounter{equation}{0}
     \llbracket \mathsf{SMA} \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \llbracket \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA})) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \llbracket \mathit{act}(\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     Beginning with the left side of the union unraveled further, and evaluated over $(\mathit{is}_{[\mathsf{SI}]},\mathit{rs})$, the simplification using Lemma \#1 results in (6):
 \begin{align}
     \llbracket \mathit{act} (\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \llbracket \mathit{act} (PC=0\ldots 100) \rrbracket (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup \ldots %should probably use element of insead of = for is_{PC}
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup \ldots 
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     The right side can be evaluated similarly.
 \begin{align}
     \ldots \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cap
     \llbracket \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     \llbracket \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\ %
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     (\mathit{is_{\mathsf{SI}}}, \llbracket (\neg\mathsf{SA}) \rrbracket \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs}) \cap
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs} - \llbracket (\mathsf{SA}) \rrbracket \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}') %
     \\
     \ldots \cup 
     (\emptyset, \mathit{rs} - \llbracket (\mathsf{SA}) \rrbracket \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     The left side of the intersection can be evaluated to $(\emptyset, \mathit{rs})$ Lemma \#2 from (8) to (9). The right side of the intersection can be evaluated by the definition of negation and result slicing, (9) to (11).  The intersection is then evaluated over both to give (12).  The union can be evaluated as:
 \begin{align}
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs}) \cup 
     (\emptyset, \mathit{rs} - \llbracket (\mathsf{SA}) \rrbracket \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{PC=0\ldots100}}, \mathit{rs})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align} 
     (13) simplifies to (14) because the union of a set and the empty set is the first set, and the expression $\mathit{rs} - \llbracket (\mathsf{SA}) \rrbracket \mathit{rs}$ is by definition a subset of $\mathit{rs}$.  This leaves $\mathit{rs} = \mathit{rs}'$, proving part 1. 

 \paragraph{Proof 3.2.2}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over insecure actions and results is to be proven to not change the results.  This idea can be written to equal some $(\mathit{is}', \mathit{rs}')$, and then simplified in the same way as the beginning of Proof 3.2.1
 \begin{align}
     \setcounter{equation}{0}
     \llbracket \mathsf{SMA} \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \llbracket \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}))  \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \llbracket \mathit{act}(\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     Following the same format, the expression to the left of the union is evaluated first.
 \begin{align}
     \llbracket \mathit{act}(\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}}) \cup \ldots
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     Lemma \#2 in the previous proof simplifies this easily.\\
     The expression to the right of the union is now evaluated.
 \begin{align}
     \ldots \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     \llbracket \mathit{act}(\neg\mathsf{SI}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     \llbracket \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     \llbracket \mathit{res}(\neg\mathsf{SA}) \rrbracket (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \cap
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     \ldots \cup % or would + be better?
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     Lemma \#1 is used to simplfy the left side of the intersection, and a result-version of Lemma \#1 is used to simplify the right side of the intersection. (10) contains the evaluated intersection.\\
     The left and right sides of the union can be rejoined and evaluated to determine the exact equivalence of $(\mathit{is}', \mathit{rs}')$:
 \begin{align}
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}}) \cup
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
     \\
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is}', \mathit{rs}')
 \end{align}
     In (12), it is shown that the evaluated results are unchanged, and it can additionally be said that none of the instructions have been changed from the initial input as well.  This proves part 2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lock Bits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each instruction is associated with a lock bit.
Only the monitor can update lock bits.
Certain operations like writing to a particular part of the address space
require that the lock bit be set. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{rcl}
  \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{Lock_{Instr}}, \mathsf{IC}\\
  \mathsf{IC} &::=& \mathsf{MEM_{READ}}\ |\ \mathsf{MEM_{WRITE}}\ |\ \cdots \\
  \mathit{Result\ Fields}\ f_r &::=& \mathsf{Lock_{MemAddr}}\\
  \mathsf{LockedInstr} &\triangleq& \mathsf{Lock_{Instr}} = \mathsf{TRUE} \\
  \mathsf{LockedMem} &\triangleq& \mathsf{Lock_{MemAddr}} = \mathsf{TRUE} \\
  \mathsf{Read} &\triangleq& \mathsf{IC} = \mathsf{MEM_{READ}}\\
  \mathsf{Write} &\triangleq& \mathsf{IC} = \mathsf{MEM_{WRITE}}\\
  %Rule
  \mathsf{LockSecure} &\triangleq& 
    act(\mathsf{LockedInstr})\cdot res(\mathsf{LockedMem})\\
    &&+
    act(\mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem}) \cdot \mathsf{inj_{MEM-LOCK}} \\
  \mathsf{LockInsecure} &\triangleq&
    act(\neg \mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem})\\
  \mathsf{Locked} &\triangleq& \mathsf{LockSecure} + \mathsf{LockInsecure}
\end{array}
\]\\
$\mathsf{Locked}$ is defined in english as "Any locked instruction can access anything, but it must lock it if it's not locked.  Any unlocked instruction can only access unlocked memory."\\
It would be interesting to prove if this is equal to the locked instruction accessing ANYTHING, and then ALWAYS setting it to locked.

%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 3 %%%
%%% APPLICATIONS    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
