%Seaghan Sefton
%Research Language Paper
%Work in Progress


%Preamble%
    \documentclass[12pt, letterpaper]{article}
    \usepackage{pdfpages} %for including PDFs. see Graphicx for more info
    \usepackage{amsmath} %for \mvert and other relation symbol
    \usepackage{amssymb} %for semantic delta=
    \usepackage{amsthm} 
    \usepackage{stmaryrd} %for semantics [[ and ]]
    \usepackage{dsfont} %for fancy set letters
    \usepackage{fancyhdr} %fancy headers
    %\usepackage{array} %Include if {tabular}{>{$}c<{$}} type arrays are required
    \let\emptyset\varnothing
    \pagestyle{fancy}
    \lhead{Seaghan Sefton}
    \rhead{Page \thepage}

\title{Research Language}
\author{Seaghan Sefton}
%the above title and author are unecessary

\newcommand\interp[1]{\llbracket #1 \rrbracket}

\begin{document}

\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 1 %%%
%%% SYNTAX          %%%
%%%%%%%%%%%%%%%%%%%%%%%

    %Definitions table
    \begin{tabular}{l r c l}
        Instruction Fields   & $f_{i}$   & $::=$     & $f_{i_{1}} \mid \dots \mid f_{i_{k}}$\\
        Result Fields   & $f_{r}$   & $::=$     & $f_{r_{1}} \mid \dots \mid f_{r_{k}}$\\
        Fields          & $f$       & $::=$     & $f_i \mid f_r$ \\
        Instructions         & $i$       & $::=$     & $\{f_{i_{1}} = v_{i_{1}} ,\ \dots\ ,\ f_{i_{k}} = v_{i_{k}}\}$\\
        Results         & $r$       & $::=$     & $\{f_{r_{1}} = v_{r_{1}} ,\ \dots\ ,\ f_{r_{k}} = v_{r_{k}}\}$\\
    \end{tabular}\\

    %Predicates table
    \begin{tabular}{l c r l l}
        Predicates  & $a,b$     & $::=$  & $0$          & \textit{Identity} \\
                    &           & $\mid$ & $1$          & \textit{False}    \\
                    &           & $\mid$ & $f=n$        & \textit{Test} \\  
                    &           & $\mid$ & $a + b$      & \textit{Sum}      \\
                    &           & $\mid$ & $a \cdot b$  & \textit{Product}  \\
                    &           & $\mid$ & $\neg \ a$   & \textit{Negation}
    \end{tabular}\\

    %Policies table
    \begin{tabular}{l c r l l}
        Policies    & $p,q$ & $::=$  & $a$              & \textit{Test}     \\
                    &       & $\mid$ & $act(p)$         & \textit{Slice Actions}    \\
                    &       & $\mid$ & $res(p)$         & \textit{Slice Results}    \\
                    &       & $\mid$ & $inj_{i}$        & \textit{Injection Action} \\
                    &       & $\mid$ & $inj_{r}$        & \textit{Injection Result} \\
                    &       & $\mid$ & $f \leftarrow n$ & \textit{Update}   \\
                    &       & $\mid$ & $p + q$          & \textit{Choice}   \\
                    &       & $\mid$ & $p \cdot q$      & \textit{Sequential Concatenation} \\
                    &       & $\mid$ & $p ^{*}$         & \textit{Kleene Star}
    \end{tabular}\\
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 1 %%%
%%% SYNTAX           %%%
%%%%%%%%%%%%%%%%%%%%%%%%


%Semantics Definitions
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 2 %%%
%%% SEMANTICS       %%%
%%%%%%%%%%%%%%%%%%%%%%%
 %{\fontsize{12pt}{14pt}\selectfont
    %Semantics align
    \begin{align*}
        %
        \interp{ \cdot }\ 
            :\ \ &
            P(A)\times P(R) \rightarrow P(A)\times P(R) 
            \\
        %Falsity
        \interp{ 0 }(-, -)
            \triangleq\ &
            (\emptyset , \emptyset)
            \\ %or should I use {}?
        %Identity
        \interp{ 1 }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \mathit{rs})
            \\
        %Test
        \interp{ f=n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{filter}\ (f=n)\ \mathit{is},
             \mathsf{filter}\ (f=n)\ \mathit{rs}) 
            \\
        %Sum
        \interp{ a + b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp{ a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp{ b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cup \mathit{is}_b,\mathit{rs}_a \cup \mathit{rs}_b) 
            \\
        %Product
        \interp { a \cdot b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp { b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cap \mathit{is}_b,\mathit{rs}_a \cap \mathit{rs}_b) 
            \\
        %Negation
        \interp { \neg a }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is} - \mathit{is}',\mathit{rs} - \mathit{rs}') 
            \\
        %Action-only Slice
        \interp { act(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is}',\mathit{rs}) 
            \\
        %Result-only Slice
        \interp { res(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is},\mathit{rs}')
            \\
        %Injection Action
        \interp { inj_{i}(i) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\{i\} \cup \mathit{is}, \mathit{rs})
            \\
        %Injection Result
        \interp { inj_{r}(r) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \{r\} \cup \mathit{rs})
            \\
        %Modification
        \interp { f \leftarrow n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{map}\ (f\leftarrow n)\ \mathit{is},
             \mathsf{map}\ (f\leftarrow n)\ \mathit{rs})
            \\
        %Policy Union
         \interp { p + q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_p,\mathit{rs}_p) =
            \interp { p }(\mathit{is}, \mathit{rs}) 
            \\
            &\mathsf{let}\ (\mathit{is}_q,\mathit{rs}_q) =
            \interp { q }(\mathit{is}, \mathit{rs}) 
            \\
            &(\mathit{is}_p \cup \mathit{is}_q,\mathit{rs}_p \cup \mathit{rs}_b) 
            \\
        %Policy Concatnation
        \interp { p \cdot q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') =
            \interp { p }(\mathit{is}, \mathit{rs})
            \\
            &\interp { q }(\mathit{is}', \mathit{rs}')
            \\
        %Policy Kleene Star
        \interp { p ^{*} } (\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ p^{n} = p_{1} \cdot p_{2} \cdot \ldots \cdot p_{n}
            \\
            &\mathsf{let}\ (\mathit{is_{p_{n}}}, \mathit{rs_{p_{n}}}) = \interp { p^{n} } (is, rs)
            \\
            &(\bigcup^{\infty}_{n=0} \mathit{is_{p_{n}}}, \bigcup^{\infty}_{n=0} \mathit{rs_{p_{n}}})
            \\ 
    \end{align*}
    %This is required because it will overflow the page otherwise.
    \begin{align*}
        \mathsf{let}\ l \in\ & is\cup rs\\
        %Defn. of Filter
        %\interp{\mathsf{filter}(f=n)}(is)
        %    \triangleq\ & \{i \in is\ |\ i_f = n\}\\
        %not sure which is better, also it could be defined discretely over is and rs but that is repetitive.
        %\interp{\mathsf{filter}(f=n)}(ls)
        %    \triangleq\ & \{l \in ls\ |\ l_f = n\}\\
        \interp{\mathsf{filter}\ f}(ls)
            \triangleq\ & \{l \in ls\ |\ f(l) = \mathsf{true}\}\\
        %Defn. of Map
        %\interp{\mathsf{map}\ g}(is)
        %    \triangleq\ &
        %    \{ g(i)\ |\ i\in is \} \\
        \interp{\mathsf{map}\ g}(ls)
            \triangleq\ &
            \{ g(l)\ |\ l\in ls \} \\
    \end{align*}
 %}
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 2 %%%
%%% SEMANTICS        %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Applications}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 3 %%%
%%% APPLICATIONS    %%%
%%%%%%%%%%%%%%%%%%%%%%%

\subsection{No Writes To $\mathsf{R}_0$}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{R}_{\mathsf{dest}} \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{(*empty*)}\\
   \mathsf{WritesToZero} &\triangleq& \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0 \\
   \mathsf{NoWritesToZero} &\triangleq& \mathit{act}(\neg\mathsf{WritesToZero})
 \end{array}
 \]%equation brackets unecessary?
 
 Prove that
 \begin{itemize}
 \item  if
   $\interp{ \mathsf{NoWritesZero} } (\mathit{is}, \mathit{rs}) =
   (\mathit{is}', \mathit{rs}')$
 \item then
   \begin{enumerate}
   \item $\mathit{rs} = \mathit{rs'}$ and
   \item for all $i \in \mathit{is}'$, $i.\mathsf{R}_{\mathsf{dest}} \neq \mathsf{R}_0$.
   \end{enumerate}
 \end{itemize}
 \begin{proof}
 %    \hfill  \\
 %  \begin{tabular}{rl}
 %    %\label{step1}
 %    $\interp{\mathsf{NoWritesToZero}}
 %    = \interp{\mathit{act}(\neg \mathsf{WritesToZero})}$
 %    & Defn.\\
 %    %\label{step2}
 %    $\interp{\mathit{act}(\neg \mathsf{WritesToZero})}
 %    = \interp{act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}$
 %    & Defn.\\
 %    %\label{step3}
 %    $\interp{act(\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0))}(\mathit{is},\mathit{rs})
 %    = ((\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
 %    & Defn. $\interp{\cdot}$\\    
 %    %\label{step4}
 %    $\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})
 %    = (\mathit{is},\mathit{rs}) - \interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})$
 %    & Defn. $\interp{\cdot}$\\    
 %    %\label{step5}
 %    $\interp{\mathsf{NoWritesToZero}}(\mathit{is},\mathit{rs})
 %    = (\mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1, \mathit{rs})$
 %    & \ref{step1,step2,step3,step4}\\
 %    %\label{step6}
 %    $is' = \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1$ & \ref{step5} \\
 %    %\label{step7}
 %    $rs' = rs$ & \ref{step5}
 %  \end{tabular}
 
 %Reference https://tex.stackexchange.com/questions/33585/change-font-size-of-an-align-environment
 %Allows the proof to be smaller without changing the entire paper font size.  Paper can be reduced in size in the future but the proofs can remain smaller for width reasons.
 Thm 3.1.1 and Thm 3.1.2:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
   \begin{alignat}{2}
     \setcounter{equation}{0}
     %\text{Statements} &&\quad \text{Reasons}\\
     \label{3.1.1:step1}
     \interp{\mathsf{NoWritesToZero}}
     &= \interp{\mathit{act}(\neg \mathsf{WritesToZero})}
     &&\quad \text{Defn.}\\
     \label{3.1.1:step2}
     %\interp{\mathit{act}(\neg \mathsf{WritesToZero})}
     &= \interp{act(\neg \mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}
     &&\quad \text{Defn.}\\
     \label{3.1.1:step3}
     \interp{act(\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0))}(\mathit{is},\mathit{rs})
     &= ((\interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})).1, \mathit{rs})
     &&\quad \text{Defn.}\ \interp{\cdot}\\    
     \label{3.1.1:step4}
     \interp{\neg(\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0)}(\mathit{is},\mathit{rs})
     &= (\mathit{is},\mathit{rs}) - \interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})
     &&\quad \text{Defn.}\ \interp{\cdot}\\    
     \label{3.1.1:step5}
     \interp{\mathsf{NoWritesToZero}}(\mathit{is},\mathit{rs})
     &= (\mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1, \mathit{rs})
     &&\quad \ref{3.1.1:step2},\ \ref{3.1.1:step3},\ \ref{3.1.1:step4}\\
     \label{3.1.1:step6}
     is' &= \mathit{is} - (\interp{\mathsf{R}_{\mathsf{dest}} = \mathsf{R}_0}(\mathit{is},\mathit{rs})).1
     &&\quad \ref{3.1.1:step5} \\
     %Add, by deconstruction of (is,rs) pair?
     \label{3.1.1:step7}
     rs' &= rs 
     &&\quad \ref{3.1.1:step5} \\
     %Add, by deconstruction of (is,rs) pair?
     \label{3.1.1:qed}
     %& \mathsf{Q.E.D.}
     &\qedhere
    &&\quad \ref{3.1.1:step6},\ \ref{3.1.1:step7}
   \end{alignat}
 }%
 \end{proof}
 
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.1 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Secure Memory Access}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{PC} \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{ADDR} \\
   \mathsf{SecureAddr} &\triangleq& \mathsf{ADDR} = 0 + \mathsf{ADDR} = 1 + \ldots + \mathsf{ADDR} = 100 \\
   \mathsf{SecureInstr} &\triangleq& \mathsf{PC} = 0 + \mathsf{PC} = 1 + \ldots + \mathsf{PC} = 100 \\
 %  \mathsf{MemInstr} &\triangleq& \mathsf{OPCODE} = \mathsf{read} + \mathsf{OPCODE} = \mathsf{write} \\
   \mathsf{SecureMemoryAccess} &\triangleq&
     \mathit{act}(\mathsf{SecureInstr}) +
     (\mathit{act}(\neg\mathsf{SecureInstr}) \cdot
      \mathit{res}(\neg\mathsf{SecureAddr}))
      
 \end{array}
 \]

 Prove
 \begin{itemize}
     \item the results of secure instructions are unchanged, and
     \item the results of insecure instructions accessing insecure areas are unchanged.
 \end{itemize}

 \paragraph{Lemma \#1}
     A filter sliced to actions over a set where the actions satisfy the filter, returns itself.
 \[
     \interp{ act(f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs}) = (\mathit{is_{\mathsf{A}}}, \mathit{rs})
 \]
 \begin{proof}
     It suffices to prove that the result is unchanged when the policy is interpreted over the given set.
     \par\nobreak
     {\fontsize{10pt}{12pt}\selectfont
     \begin{alignat}{2}
         \setcounter{equation}{0}
         %\label{3.2.L.1:step1}
         %\interp{ act(f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         %&= 
         %(\mathit{is}', \mathit{rs}')
         %&&\quad \text{Defn.}
         %\\
         \label{3.2.L.1:step2}
         \interp{ act(f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         &= 
         ((\interp{ (f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})).1, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\cdot}\\
         \label{3.2.L.1:step3}
         %(\interp{ (f=\mathsf{A}) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &=
         (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\mathsf{filter}}\\
         \label{3.2.L.1:qed}
         &\qedhere
         &&\quad \ref{3.2.L.1:step2},\ \ref{3.2.L.1:step3}
     \end{alignat}
     }%
    \end{proof}
     \paragraph{*} Note that the same process can be applied to results.
    \begin{proof}
     {\fontsize{10pt}{12pt}\selectfont
     \begin{alignat}{2}
         \setcounter{equation}{0}
         %\label{3.2.L.1:step1}
         %\interp{ act(f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         %&= 
         %(\mathit{is}', \mathit{rs}')
         %&&\quad \text{Defn.}
         %\\
         \label{3.2.L.1*:step2}
         \interp{ res(f=\mathsf{A}) } (\mathit{is}, \mathit{rs}_{\mathsf{A}})
         &= 
         ((\interp{ (f=\mathsf{A}) } (\mathit{is}, \mathit{rs}_{\mathsf{A}})).2, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\cdot}\\
         \label{3.2.L.1*:step3}
         %(\interp{ (f=\mathsf{A}) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &=
         (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\mathsf{filter}}\\
         \label{3.2.L.1*:qed}
         &\qedhere
         &&\quad \ref{3.2.L.1:step2},\ \ref{3.2.L.1:step3}
     \end{alignat}
     }
 \end{proof}
 \paragraph{Lemma \#2}
     It follows that the converse would result in no $\mathit{is}$ in the evaluated set:
 \[
     \interp{ act(\neg (f=\mathsf{A})) } (\mathit{is}_{\mathsf{A}}, \mathit{rs}) = (\emptyset, \mathit{rs})
 \] %extra parentheses added to separate \neg and f=A, may be unecessary if \neg is defined to bind less strongly than a condition/filter.
 \begin{proof}
     It suffices to prove that the result has no $\mathit{is}$ when the policy is interpreted over the given set.
     \par\nobreak
     {\fontsize{10pt}{12pt}\selectfont
     \begin{alignat}{2}
         \setcounter{equation}{0}
         %\label{3.2.L.2:step1}
         %\interp{ act(\neg f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         %&= 
         %(\mathit{is}', \mathit{rs}')
         %&&\quad \text{Defn.}
         %\\
         \label{3.2.L.2:step2}
         \interp{ act(\neg (f=\mathsf{A})) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})
         &= 
         (\interp{ (\neg (f=\mathsf{A})) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\cdot}\\
         \label{3.2.L.2:step3}
         %(\interp{ (\neg f=\mathsf{A}) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &=
         (\mathit{is}_{\mathsf{A}} - (\interp{ (f=\mathsf{A}) } (\mathit{is}_{\mathsf{A}}, \mathit{rs})).1, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\mathsf{filter}}\\
         \label{3.2.L.2:step4}
         %(\interp{ (\neg f=\mathsf{A}) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &=
         (\mathit{is}_{\mathsf{A}} - \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\mathsf{filter}}\\
         \label{3.2.L.2:step5}
         %(\interp{ (\neg f=\mathsf{A}) } \mathit{is}_{\mathsf{A}}, \mathit{rs})
         &=
         (\emptyset, \mathit{rs})
         &&\quad \text{Defn.}\ \interp{\mathsf{filter}}\\
         \label{3.2.L.2:qed}
         &\qedhere
         &&\quad \ref{3.2.L.2:step2},\ \ref{3.2.L.2:step5}
     \end{alignat}
     }%
 \end{proof}

 \paragraph{Proof 3.2.1}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over some $(\mathit{is},\mathit{rs})$ can be unraveled given the above definitions.  $\mathsf{SI}$ is short for $\mathsf{SecureInstr}$, $\mathsf{SA}$ is short for $\mathsf{SecureAddr}$, and $\mathsf{SMA}$ is short for $\mathsf{SecureMemoryAccess}$:\\
 \begin{proof}
     if
     \[
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     =
     (\mathit{is}', \mathit{rs}')
     \]
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \setcounter{equation}{0}
     \label{3.2.1:step1}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     \interp{ \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA})) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.}\ \mathsf{SMA}
     \\
     \label{3.2.1:step2}
     %\interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.}\ \interp{+}
     \\
     \label{3.2.1:step3}
     (\mathit{is}', \mathit{rs}')
     &=
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.},\ \ref{3.2.1:step2}
 \end{alignat}
 }%
     This proof will be broken into two parts for spacial simplicity.  The left side of the union will be evaluated, then the right, and finally both will be combined.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \label{3.2.1:step4}
     \interp{ \mathit{act} (\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})  
     &=
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs})   %should probably use element of insead of = for is_{PC}
     &&\quad \text{Lemma \#1}
     %\\
     %\label{3.2.1:step5}
     %\interp{ \mathit{act} (\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})  
     %&=
     %(\mathit{is_{PC=0\ldots 100}}, \mathit{rs})
     %&&\quad \text{Defn.}\ \mathsf{SI},\ \ref{3.2.1:step4}
 \end{alignat}
 }%
     The right side can be evaluated similarly.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \label{3.2.1:step6}
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})\\ %%Err
     \nonumber
     &\quad \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.}\ \interp{\cdot}
     \\ %ERR: bug with numbering lines that shouldn't be numbered
     \label{3.2.1:step7}
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\emptyset, \mathit{rs})
     &&\quad \text{Lemma \#2}
     \\
     \label{3.2.1:step8}
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is_{\mathsf{SI}}}, (\interp{ (\neg\mathsf{SA}) } (\mathit{is}, \mathit{rs})).2)
     &&\quad \text{Defn.}\ \interp{\cdot}
     \\
     \label{3.2.1:step9}
     %(\mathit{is_{\mathsf{SI}}}, \interp{ (\neg\mathsf{SA}) } \mathit{rs})
     &=
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs} - (\interp{ (\mathsf{SA}) } (\mathit{is}, \mathit{rs})).2)
     &&\quad \text{Defn.}\ \interp{\mathsf{filter}}
     \\
     %\label{3.2.1:step10}
     %\interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     %&=
     %(\mathit{is_{\mathsf{SI}}}, \mathit{rs} - \interp{ (\mathsf{SA}) } \mathit{rs})
     %&&\quad \ref{3.2.1:step8},\ \ref{3.2.1:step9}
     %\\
     \label{3.2.1:step10}
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\emptyset, \mathit{rs})
     \\
     \nonumber
     &\quad \cap
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs} - (\interp{ (\mathsf{SA}) } (\mathit{is}, \mathit{rs})).2)
     &&\quad \ref{3.2.1:step6},\ \ref{3.2.1:step7},\ \ref{3.2.1:step9}
     \\
     \label{3.2.1:step11}
     %\interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
     % \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\emptyset, \mathit{rs} - (\interp{ (\mathsf{SA}) } (\mathit{is}, \mathit{rs})).2)
     &&\quad \text{Defn.}\ \cap
 \end{alignat}
 }%
     The union can be evaluated as:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \label{3.2.1:step12}
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs}) \cup 
     (\emptyset, \mathit{rs} - (\interp{ (\mathsf{SA}) } (\mathit{is}, \mathit{rs})).2)
     &=
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.}\ \cup
     \\
     \label{3.2.1:step13}
     (\mathit{is}', \mathit{rs}')
     &=
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \ref{3.2.1:step3},\ \ref{3.2.1:step4},\ \ref{3.2.1:step11},\ \ref{3.2.1:step12}
     \\
     \label{3.2.1:step14}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &=
     (\mathit{is_{\mathsf{SI}}}, \mathit{rs})
     &&\quad \text{Defn.},\ \ref{3.2.1:step13}
     \\
     \label{3.2.1:qed}
     &\qedhere
     &&\quad \ref{3.2.1:step14}
 \end{alignat}
 }% 
     It has been shown that the results of the interpretation have been unchanged and therefore the proof need not continue further.
 \end{proof}

 \paragraph{Proof 3.2.2}
     The evaluation of $\mathsf{SecureMemoryAccess}$ over insecure actions and results does not change the results.  This idea can be written to equal some $(\mathit{is}', \mathit{rs}')$, and then simplified in the same way as the beginning of Proof 3.2.1

 \begin{proof}
 It suffices to prove that:
     \[
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     =
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     \]
 %\par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \setcounter{equation}{0}
     \label{3.2.2:step1}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     \interp{ \mathit{act}(\mathsf{SI}) +
     (\mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}))  } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Defn.}\ \mathsf{SMA}
     \\
     \label{3.2.2:step2}
     %\interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}}) \\
     \nonumber
     &\quad \cup % or would + be better?
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Defn.}\ \interp{+},\ \ref{3.2.2:step1}
 \end{alignat}
 }%
     Following the same format, the expression to the left of the union is evaluated first.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \label{3.2.2:step3}
     \interp{ \mathit{act}(\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Lemma \#2}
 \end{alignat}
 }%
     Lemma \#2 in the previous proof simplifies this easily.\\
     The expression to the right of the union is now evaluated.
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
       % or would + be better?
     \label{3.2.2:step4}
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})\\ \nonumber
     &\quad \cap
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Defn.} \interp{\cdot}
     \\
     \label{3.2.2:step5}
     \interp{ \mathit{act}(\neg\mathsf{SI}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Lemma \#1}
     \\
     \label{3.2.2:step6}
     \interp{ \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Lemma \#1*} %note that this is really lemma 1 for results, not actions
     \\
     \label{3.2.2:step7}
     \interp{ \mathit{act}(\neg\mathsf{SI}) \cdot
      \mathit{res}(\neg\mathsf{SA}) } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})\\ \nonumber
     &\quad \cap
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \ref{3.2.2:step4},\ \ref{3.2.2:step5},\ \ref{3.2.2:step6}
     \\
     \label{3.2.2:step8}
     &=
     (\mathit{is}', \mathit{rs}')
     &&\quad \text{Defn.}\ \cap,\ \ref{3.2.2:step7}
 \end{alignat}
 }%
     Lemma \#1 is used to simplfy the left side of the intersection, and in (\ref{3.2.2:step6}) a result-version of Lemma \#1, Lemma \#1*, is used to simplify the right side of the intersection. (\ref{3.2.2:step8}) contains the evaluated intersection.\\
     The left and right sides of the union can be rejoined and evaluated to determine the exact equivalence of $(\mathit{is}', \mathit{rs}')$:
 \par\nobreak
 {\fontsize{10pt}{12pt}\selectfont
 \begin{alignat}{2}
     \label{3.2.2:step9}
     \interp{ \mathsf{SMA} } (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &=
     (\emptyset, \mathit{rs_{\mathsf{\neg SA}}}) \cup
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \ref{3.2.2:step2},\ \ref{3.2.2:step3},\ \ref{3.2.2:step8}
     \\
     \label{3.2.2:step10}
     &=
     (\mathit{is_{\mathsf{\neg SI}}}, \mathit{rs_{\mathsf{\neg SA}}})
     &&\quad \text{Defn.}\ \cup,\ \ref{3.2.2:step9}
     \\
     \label{3.2.2:qed}
     &\qedhere
     &&\quad \ref{3.2.2:step10}
 \end{alignat}
 }%
     In (\ref{3.2.2:qed}), it is shown that the evaluated results are unchanged, and it can additionally be said that none of the instructions have been changed from the initial input as well.  This proves part 2.
  \end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.2 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Lock Bits}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Each instruction is associated with a lock bit.
 Only the monitor can update lock bits.
 Certain operations like writing to a particular part of the address space
 require that the lock bit be set. 

 \[
 \begin{array}{rcl}
   \mathit{Instruction\ Fields}\ f_i &::=& \mathsf{Lock_{Instr}}, \mathsf{OP}\\
   \mathsf{OP} &::=& \mathsf{MEM_{READ}}\ |\ \mathsf{MEM_{WRITE}}\ |\ \cdots \\
   \mathit{Result\ Fields}\ f_r &::=& \mathsf{Lock_{MemAddr}}\\
   \mathsf{LockedInstr} &\triangleq& \mathsf{Lock_{Instr}} = \mathsf{TRUE} \\
   \mathsf{LockedMem} &\triangleq& \mathsf{Lock_{MemAddr}} = \mathsf{TRUE} \\
   \mathsf{Read} &\triangleq& \mathsf{OP} = \mathsf{MEM_{READ}}\\
   \mathsf{Write} &\triangleq& \mathsf{OP} = \mathsf{MEM_{WRITE}}\\
   \mathsf{MemLock} &\triangleq& \mathsf{Lock_{MemAddr}} \leftarrow \mathsf{TRUE}\\ 
   %Rule
   \mathsf{LockSecure} &\triangleq& 
     act(\mathsf{LockedInstr})\cdot res(\mathsf{LockedMem})\\
     &&+
     act(\mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem}) \cdot \mathit{inj_{\mathsf{MemLock}}} \\
   \mathsf{LockInsecure} &\triangleq&
      act(\neg \mathsf{LockedInstr})\cdot res(\neg \mathsf{LockedMem})\\
   \mathsf{Locked} &\triangleq& \mathsf{LockSecure} + \mathsf{LockInsecure}
 \end{array}
 \]\\
 $\mathsf{Locked}$ is defined in english as "Any locked instruction can access anything, but it must lock it if it's not locked.  Any unlocked instruction can only access unlocked memory."\\
 It would be interesting to prove if this is equal to the locked instruction accessing ANYTHING, and then ALWAYS setting it to locked.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SUBSECTION 3.3 %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 3 %%%
%%% APPLICATIONS    %%%%
%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 4     %%%
%%% SYNTAX INTERMEDIATE %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %Definitions table
    \begin{tabular}{l r c l}
        Instruction Fields   & $f_{i}$   & $::=$     & $f_{i_{1}} \mid \dots \mid f_{i_{k}}$\\
        Result Fields   & $f_{r}$   & $::=$     & $f_{r_{1}} \mid \dots \mid f_{r_{k}}$\\
        Fields          & $f$       & $::=$     & $f_i \mid f_r$ \\
        Instructions         & $i$       & $::=$     & $\{f_{i_{1}} = v_{i_{1}} ,\ \dots\ ,\ f_{i_{k}} = v_{i_{k}}\}$\\
        Results         & $r$       & $::=$     & $\{f_{r_{1}} = v_{r_{1}} ,\ \dots\ ,\ f_{r_{k}} = v_{r_{k}}\}$\\
    \end{tabular}\\

    %Predicates table
    \begin{tabular}{l c r l l}
        Predicates  & $a,b$     & $::=$  & $0$          & \textit{False} \\
                    &           & $\mid$ & $1$          & \textit{Identity}    \\
                    &           & $\mid$ & $f=n$        & \textit{Test} \\  
                    &           & $\mid$ & $a + b$      & \textit{Sum}      \\
                    &           & $\mid$ & $a \cdot b$  & \textit{Product}  \\
                    &           & $\mid$ & $\neg \ a$   & \textit{Negation}
    \end{tabular}\\

    %Policies table
    \begin{tabular}{l c r l l}
        Policies    & $p,q$ & $::=$  & $a$              & \textit{Test}     \\
                    &       & $\mid$ & $act(p)$         & \textit{Slice Actions}    \\
                    &       & $\mid$ & $res(p)$         & \textit{Slice Results}    \\
                    &       & $\mid$ & $inj_{i}$        & \textit{Injection Action} \\
                    &       & $\mid$ & $inj_{r}$        & \textit{Injection Result} \\
                    &       & $\mid$ & $f \leftarrow n$ & \textit{Update}   \\
                    &       & $\mid$ & $p + q$          & \textit{Choice}   \\
                    &       & $\mid$ & $p \cdot q$      & \textit{Sequential Concatenation} \\
                    &       & $\mid$ & $p ^{*}$         & \textit{Kleene Star}
    \end{tabular}\\
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 1 %%%
%%% SYNTAX           %%%
%%%%%%%%%%%%%%%%%%%%%%%%


%Semantics Definitions
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN SECTION 2 %%%
%%% SEMANTICS       %%%
%%%%%%%%%%%%%%%%%%%%%%%
 %{\fontsize{12pt}{14pt}\selectfont
    %Semantics align
    \begin{align*}
        %
        \interp{ \cdot }\ 
            :\ \ &
            P(A)\times P(R) \rightarrow P(A)\times P(R) 
            \\
        %Falsity
        \interp{ 0 }(-, -)
            \triangleq\ &
            (\emptyset , \emptyset)
            \\ %or should I use {}?
        %Identity
        \interp{ 1 }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \mathit{rs})
            \\
        %Test
        \interp{ f=n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{filter}\ (f=n)\ \mathit{is},
             \mathsf{filter}\ (f=n)\ \mathit{rs}) 
            \\
        %Sum
        \interp{ a + b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp{ a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp{ b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cup \mathit{is}_b,\mathit{rs}_a \cup \mathit{rs}_b) 
            \\
        %Product
        \interp { a \cdot b }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_a,\mathit{rs}_a) = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &\mathsf{let}\ (\mathit{is}_b,\mathit{rs}_b) =
            \interp { b }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is}_a \cap \mathit{is}_b,\mathit{rs}_a \cap \mathit{rs}_b) 
            \\
        %Negation
        \interp { \neg a }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') = \interp { a }(\mathit{is}, \mathit{rs}) \\
            &(\mathit{is} - \mathit{is}',\mathit{rs} - \mathit{rs}') 
            \\
        %Action-only Slice
        \interp { act(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is}',\mathit{rs}) 
            \\
        %Result-only Slice
        \interp { res(p) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}')
            = \interp { p}(\mathit{is}, \mathit{rs})\ 
            \mathsf{in}\ (\mathit{is},\mathit{rs}')
            \\
        %Injection Action
        \interp { inj_{i}(i) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\{i\} \cup \mathit{is}, \mathit{rs})
            \\
        %Injection Result
        \interp { inj_{r}(r) }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathit{is}, \{r\} \cup \mathit{rs})
            \\
        %Modification
        \interp { f \leftarrow n }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            (\mathsf{map}\ (f\leftarrow n)\ \mathit{is},
             \mathsf{map}\ (f\leftarrow n)\ \mathit{rs})
            \\
        %Policy Union
         \interp { p + q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}_p,\mathit{rs}_p) =
            \interp { p }(\mathit{is}, \mathit{rs}) 
            \\
            &\mathsf{let}\ (\mathit{is}_q,\mathit{rs}_q) =
            \interp { q }(\mathit{is}, \mathit{rs}) 
            \\
            &(\mathit{is}_p \cup \mathit{is}_q,\mathit{rs}_p \cup \mathit{rs}_b) 
            \\
        %Policy Concatnation
        \interp { p \cdot q }(\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ (\mathit{is}',\mathit{rs}') =
            \interp { p }(\mathit{is}, \mathit{rs})
            \\
            &\interp { q }(\mathit{is}', \mathit{rs}')
            \\
        %Policy Kleene Star
        \interp { p ^{*} } (\mathit{is}, \mathit{rs})
            \triangleq\ &
            \mathsf{let}\ p^{n} = p_{1} \cdot p_{2} \cdot \ldots \cdot p_{n}
            \\
            &\mathsf{let}\ (\mathit{is_{p_{n}}}, \mathit{rs_{p_{n}}}) = \interp { p^{n} } (is, rs)
            \\
            &(\bigcup^{\infty}_{n=0} \mathit{is_{p_{n}}}, \bigcup^{\infty}_{n=0} \mathit{rs_{p_{n}}})
            \\ 
    \end{align*}
    %This is required because it will overflow the page otherwise.
    \begin{align*}
        \mathsf{let}\ l \in\ & is\cup rs\\
        %Defn. of Filter
        %\interp{\mathsf{filter}(f=n)}(is)
        %    \triangleq\ & \{i \in is\ |\ i_f = n\}\\
        %not sure which is better, also it could be defined discretely over is and rs but that is repetitive.
        %\interp{\mathsf{filter}(f=n)}(ls)
        %    \triangleq\ & \{l \in ls\ |\ l_f = n\}\\
        \interp{\mathsf{filter}\ f}(ls)
            \triangleq\ & \{l \in ls\ |\ f(l) = \mathsf{true}\}\\
        %Defn. of Map
        %\interp{\mathsf{map}\ g}(is)
        %    \triangleq\ &
        %    \{ g(i)\ |\ i\in is \} \\
        \interp{\mathsf{map}\ g}(ls)
            \triangleq\ &
            \{ g(l)\ |\ l\in ls \} \\
    \end{align*}
 %}
%%%%%%%%%%%%%%%%%%%%%%%%
%%% END OF SECTION 2 %%%
%%% SEMANTICS        %%%
%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
