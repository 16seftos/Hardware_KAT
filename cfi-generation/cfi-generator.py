#!/usr/bin/env python3

import sys
import subprocess

def main(binary):
  # Run bap on the provided binary, and remove the first 5 lines
  lines = subprocess.getoutput("bap " + binary + " -d --print-symbol=main")
  lines = lines.split('\n')
  lines = lines[5:]
  
  nodes = build_cfg(lines)
  ids = build_ids(nodes)
  build_cfi(nodes, ids)

# This function builds list of nodes and returns the completed list to main
# It takes the IR from bap as the input
def build_cfg(lines):
  build_node = []
  nodes = []

  for line in lines:
    # Clean up lines so they are readable
    line = line.strip('\n')
    # If the line is empty (no instruction) then a node has ended
    # If a node has been built, add it to the list of nodes
    if not line and build_node:
      nodes.append(build_node)
      build_node = []
    # If the line has an instruction then add it to the current node
    elif line:
      build_node.append(line)
    
  return get_nodes(nodes)

# This function returns a list of nodes
# It is a helper function for build_cfg
# It takes a list of the nodes build by build_cfg as an argument
def get_nodes(node_list):
  nodes = []

  # Extract the memory addresses for each node, node entrance, and node exit
  counter = 0
  for node in node_list:
    exits = []

    # Node names initially exist in the form of 'xxxxxxxx: ' where 'x' is a hex value
    name = "node" + str(counter)

    # Separate the instruction from the address of the entrance, and store only the entrance
    entrance = node[0]
    entrance = entrance.split()[0]
    entrance = entrance[:-1]

    # Iterate through every instruction in the node and extract the address for any line that contains a jump or branch
    for instr in node:
      if 'goto' in instr or 'call' in instr or 'return' in instr:
        if 'RA' in instr:
          exit = (instr.split()[0][:-1], instr.split()[-1])
        else:
          exit = (instr.split()[0][:-1], instr.split()[-1][1:])
        exits.append(exit)

    # Add the node name, entrance, and a list of exits to a list of all nodes
    nodes.append([name, entrance, exits, []])
    counter += 1

  # Populates list of direct successors in list at the end of each node
  for index, node in enumerate(nodes):
    remaining = nodes[index+1:]
    for nextnode in remaining:
      for exitpoint in node[2]:
        if nextnode[1] in exitpoint[-1]:
          node[-1].append(nextnode[0])

  return nodes

# This function builds list of ids for CFI
# It takes this list of nodes generated by build_cfg as an argument and returns the list of ids
def build_ids(nodes):
  ids = [[nodes[0][0]]]
  for index, node1 in enumerate(nodes):
    if node1[-1] and node1[-1] not in ids:
      ids.append(node1[-1])

  return ids

# This function generates cfi.v based on the information from bap
def build_cfi(node_components, ids):
  nodes = []

  # This string contains all the necessary imports, and the header for the CFI section.
  cfi_header = """Set Implicit Arguments.
Unset Strict Implicit.

Require Import Arith ZArith.
Require Import Vector. 
Require Import String.
Require Import JMeq.
Require Import List. Import ListNotations.

Require Import Integers.

Require Import lang.
Require Import combinators.


Section CFI.
  Variables i o : id TVec64.

  Definition lowerbits := Int64.repr 4095.
  Definition upperbits := Int64.repr 16773120.\n\n"""

  f = open('../src/cfi.v', 'w')
  f.write(cfi_header)

  # Builds a list of the nodes, to be stored as an integer by cfi.v
  for node in node_components:
    node_end = node[2][-1][0]
    node_start = node[1]
    node_end = str(int(node_end, 16))
    node_start = str(int(node_start, 16))
    nodes.append((node[0], node_start + node_end))

  # Writes the list of nodes to cfi.v
  for node in nodes:
    f.write("  Definition " + node[0] + " := Int64.repr " + node[1] + ".\n")

  # MISSING
  # When the current instruction is a jump, determine if the jump is allowed by the CFG
  f.write("  Definition cfi : pol :=\n")
  f.write("    PId.\n")

  f.write("(* CFI DEBUG INFO\n")
  for node in node_components:
    f.write(str(node[-1]) + '\n')
  f.write("IDS\n")
  for node in ids:
    f.write(str(node) + '\n')
  f.write(" END CFI DEBUG INFO *)\n")

  f.write("End CFI.\n")
  f.close()

# This function prints out the usage syntax if the user does not provide an argument
def usage():
  print("Usage:\n" + str(sys.argv[0]) + " <Mips Binary>")

if __name__ == "__main__":
  if len(sys.argv) != 2:
    usage()
  else:
    main(sys.argv[1])
